# !/usr/bin/env python

#
# esxplot - explore and plot data generated by the esxtop utility when
# run in 'batch' mode. This program uses the cross platform wxPython
# Window System so it should run on any Windows, Linux, or Mac OSX system
# that has Python >= 2.6 and with wxPython >= 2.8 installed

version = "esxplot v1.5-11112011"
__svnid__ = '$Id: $'
copyright = """
(c)Copyright 2011 Geoff White

This program is free software: you can redistribute it
and/or modify it under the terms of the GNU General
Public License as published by the Free Software
Foundation, either version 2 of the License, or any
later version.

This program is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public
License along with this program.  If not, see
<<http://www.gnu.org/licenses/>>.

geoffw@durganetworks.com
---
"""


# use this string to print out stats on selected metrics
minmaxavg_fmt = """{0}
Min: {1},  Max: {2},  Mean: {3:8.5},  90th Percentile: {4:8.5}
---
"""


# Tuneables
MAXQUERYLENGTH = 4096  # Maximum size of a regex query
MAXDisplayQueryLength = 20


import wx
import wx.html
import wx.lib.plot as wxPlot
import sys
import os
from optparse import OptionParser
from datetime import datetime as Datetime
from scipy.stats import scoreatpercentile



import esxp_gui
from esxp_datasource import *



# Global boolean to indicate whether we are running on MS Windows type OS
isWindowsG = False   #No by default



def log(text):
    print("[" + Datetime.today().ctime() + "] " + text)
    sys.stdout.flush()
    return


class MyFrame(esxp_gui.EsxPlotFrame):
    '''This is the main "work horse" class. Most of the methods called
    here do the brunt of the displaying and receive all of the input.
    '''
    def __init__(self, parent, id, title, csvl):
        '''Initialize our window, create all panel and widgets '''
        esxp_gui.EsxPlotFrame.__init__(self, parent, id, title,
                          wx.DefaultPosition, wx.Size(900, 450))

        self.datavector = csvl  # current dataset object reference
                                # this might become an array in future
                                # versions that deal with multiple datasets
        self.dirname = ''       # initialize for sticky directories
        self.filename = ''      # holder for filename


        # Initial preferences and parameters
        self.lgndlen = -1
        self.line_width = 1
        self.abbrv_lgd = False
        self.isGraphPresent = False  # nothing plotted yet
        self.isDatasetLoaded = False
        self.HelpIsLive = None      # True if Help window is open
        self.exp_column_dir = ""    # Holds the last directory specified by
                                    # user on CSV export
        self.itemlist = []           # array to hold multiple selections

        self.default_color = ( 'midnightblue', 'red', 'thistle', 'brown',
                               'purple', 'goldenrod', 'orangered',
                               'springgreen',
                               'steelblue', 'peru', 'orange', 'deeppink',
                               'chartreuse', 'cyan', 'fuchsia', 'maroon')
        self.color = list(self.default_color[:])

        # Bring up the GUI
        # the elements referenced here are defined in
        # esxp_gui_custom.py where the parent class is defined
        self.banner.SetLabel(label=version)
        self.menu.Append(esxp_gui.ID_ABOUT, "&About",version)
        # enable the zoom feature (drag a box around area of interest)
        self.plotter.SetEnableZoom(True)
        # Set the font size of the Title
        self.plotter.SetFontSizeTitle(12)
        # Enable Legends
        self.plotter.SetEnableLegend(True)
        # set up the Grid and tell MyPlotCanvas whether we're
        # running Windows or not
        self.plotter.SetEnableGrid(True)
        self.plotter.SetGridColour('LIGHT GREY')
        self.plotter.SetOS(isWindowsG)
        # Register call back routines for various UI elements here
        wx.EVT_MENU(self, esxp_gui.ID_EXIT,  self.TimeToQuit)
        wx.EVT_MENU(self, esxp_gui.ID_ABOUT,  self.OnAbout)
        wx.EVT_MENU(self, esxp_gui.ID_IMPORT_DATA_BATCH,  self.OnImportData)
        wx.EVT_MENU(self, esxp_gui.ID_IMPORT_QUERIES, self.OnImportQueries)
        wx.EVT_MENU(self, esxp_gui.ID_PREF,  self.OnPrefs)
        wx.EVT_MENU(self, esxp_gui.ID_EXPORT_GRAPHS,  self.OnExportGraphs)
        wx.EVT_MENU(self, esxp_gui.ID_EXPORT_COLS, self.OnExportColumns)
        wx.EVT_MENU(self, esxp_gui.ID_EXPORT_QUERIES, self.OnExportQueries)
        wx.EVT_MENU(self, esxp_gui.ID_CLOSE_DATASET, self.OnCloseDataset)
        wx.EVT_MENU(self, esxp_gui.ID_HELP,self.OnHelp)

        # Bind the OnSelChanged method to the tree
        self.tree.Bind(wx.EVT_TREE_SEL_CHANGED, self.OnSelection, id=1)
        # Bind the right click event (for query result set deletion)
        self.tree.Bind(wx.EVT_TREE_ITEM_RIGHT_CLICK, self.OnRightClick,
                       id=wx.ID_ANY)
        # Bind the OnSearchQuery method to the textctrl widget,
        # bind it to the EVT_BUTTON event
        self.queryButton.Bind(wx.EVT_BUTTON, self.OnSearchQuery, id=wx.ID_ANY)
        # Make sure we clean up any stray windows on the way out
        self.Bind(wx.EVT_CLOSE, self.OnCloseHelp)
        self.SetStatusText(version)
        self.MyTextUpdate([version, copyright])
        self.MyTextUpdate("wxPython version = " + wx.VERSION_STRING)

        if csvl != None: #if there is data loaded load the treectrl
            self.tree.MyTreeLoad(csvl)
            self.MyTextUpdate(csvl.FileInfoString)

        # Create the window in the center of the screen
        #self.Centre()

        return



    def MyAlert(self, message):
        """
        Print an alert on the screen, dismiss by clicking OK
        """
        dlg = wx.MessageDialog(self, message,"Warning!",
                               wx.OK | wx.ICON_INFORMATION)
        #log("Warning!: "+message)
        dlg.ShowModal()
        dlg.Destroy()
        return

    def MyDialog(self, message):
        """
        Brink up a dialog, require yes/no answer
        """
        dlg = wx.MessageDialog(self, message, "Response Required!", wx.YES_NO)
        val = dlg.ShowModal()
        dlg.Destroy()
        if val == wx.ID_NO:
            return False
        return True

    def MyTextUpdate(self,message):
        """
        Update the esxplot status window
        """
        if isinstance(message, str):
            self.textbox.AppendText(message)
            log(message)
        elif isinstance (message, list):
            for m in message:
                self.MyTextUpdate(m)
        return



# Call back routines
####################


    #Menu callbacks
    def TimeToQuit(self, event):
        """
        Exit the applixation
        """
        if self.HelpIsLive:
            self.HelpIsLive.Destroy()    #Destroy any Help windows lying around
        self.Close(True)                 # esxplot has left the building

    def OnCloseHelp(self, event):
        if self.HelpIsLive:
            self.HelpIsLive.Destroy()    #Destroy any Help windows lying around
        self.Destroy()


    def OnAbout(self, event):
        """
        Display an about message through a Message Dialog
        """
        about_text = version + "\n" + copyright
        dlg = wx.MessageDialog(self, about_text, "About Me",
                               wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()

    def OnPrefs(self,event):
        '''
        Called when the User selects the Preference menu item.
        Put all preferences, switches, dials and knobs, here.
        Uses the Dialog designed with wxGlade imported from esxp_gui.py
        '''
        def _load_colors():
            '''
            load the colors into the preferences panel from the frame object
            '''

            #self.color = list(self.default_color)
            dlg.tcl_rgb1.SetValue(self.color[0])
            dlg.tcl_rgb2.SetValue(self.color[1])
            dlg.tcl_rgb3.SetValue(self.color[2])
            dlg.tcl_rgb4.SetValue(self.color[3])
            dlg.tcl_rgb5.SetValue(self.color[4])
            dlg.tcl_rgb6.SetValue(self.color[5])
            dlg.tcl_rgb7.SetValue(self.color[6])
            dlg.tcl_rgb8.SetValue(self.color[7])

            dlg.tcl_rgb9.SetValue(self.color[8])
            dlg.tcl_rgb10.SetValue(self.color[9])
            dlg.tcl_rgb11.SetValue(self.color[10])
            dlg.tcl_rgb12.SetValue(self.color[11])
            dlg.tcl_rgb13.SetValue(self.color[12])
            dlg.tcl_rgb14.SetValue(self.color[13])
            dlg.tcl_rgb15.SetValue(self.color[14])
            dlg.tcl_rgb16.SetValue(self.color[15])
            return

        def _color_reset(event):
            '''
            Reset the colors to the initial defaults when the button is pushed
            '''
            self.color = list(self.default_color)
            _load_colors()
            return

        # call the Dialog constructor created by wxGlade
        dlg = esxp_gui.EsxPlotPreferencesDialog(None, -1)
        dlg.button_color_reset.Bind(wx.EVT_BUTTON, _color_reset, id=wx.ID_ANY)

        if self.line_width == 1:
            dlg.radio_linew1.SetValue(True)
        else:
            dlg.radio_linew2.SetValue(True)

        if self.abbrv_lgd:
            dlg.chkb_lgd.SetValue(True)
            dlg.tcl_lgd.SetValue(str(self.lgndlen) )
        else:
            dlg.chkb_lgd.SetValue(False)
            dlg.tcl_lgd.SetValue(str(" "))

        # Load colors that have been saved
        _load_colors()

        # If the user pressed OK, there may be preference changes to process
        if dlg.ShowModal()== wx.ID_OK:
            if dlg.radio_linew1.GetValue():
                self.line_width = 1
            else:
                self.line_width = 2
            if dlg.chkb_lgd.GetValue():
                self.abbrv_lgd = True
                try:
                    rval = int(dlg.tcl_lgd.GetValue())
                except ValueError:
                    self.MyAlert("illegal legend length, not changed")
                    rval = self.lgndlen
                self.lgndlen = rval

            else:
                self.abbrv_lgd = False
                self.lgndlen = -1

            if self.lgndlen > 100:
                self.lgndlen = 100
            elif self.lgndlen < -1:
                self.lgndlen = -1
                self.abbrv_lgd = False

            # save the colors in case they were changed.
            self.color[0] = dlg.tcl_rgb1.GetValue()
            self.color[1] = dlg.tcl_rgb2.GetValue()
            self.color[2] = dlg.tcl_rgb3.GetValue()
            self.color[3] = dlg.tcl_rgb4.GetValue()
            self.color[4] = dlg.tcl_rgb5.GetValue()
            self.color[5] = dlg.tcl_rgb6.GetValue()
            self.color[6] = dlg.tcl_rgb7.GetValue()
            self.color[7] = dlg.tcl_rgb8.GetValue()
            self.color[8] = dlg.tcl_rgb9.GetValue()
            self.color[9] = dlg.tcl_rgb10.GetValue()
            self.color[10] = dlg.tcl_rgb11.GetValue()
            self.color[11] = dlg.tcl_rgb12.GetValue()
            self.color[12] = dlg.tcl_rgb13.GetValue()
            self.color[13] = dlg.tcl_rgb14.GetValue()
            self.color[14] = dlg.tcl_rgb15.GetValue()
            self.color[15] = dlg.tcl_rgb16.GetValue()

            self.MyTextUpdate("%Preferences have changed\n")
        else:
            pass

        dlg.Destroy()

        self.OnSelection(event)  #redraw the plot with new preferences
        return

    def OnHelp(self,event):
        if self.HelpIsLive:
            dlg = self.HelpIsLive
        else:
            dlg = MyHelpDialog()

        html = wx.html.HtmlWindow(dlg, pos=(10, 10), size=(780, 430),
                                  style=wx.html.HW_SCROLLBAR_AUTO )
        html.SetStandardFonts()
        html.SetPage(man_page )
        dlg.Show()
        self.HelpIsLive = dlg
        return

    def OnImportData(self, event): ### candidate for refactoring for 1.1
        """
        Get a file containing data from the user
        """

        if self.isDatasetLoaded:
            self.MyAlert("A data set has already been loaded")
            return


        dlg = wx.FileDialog(self, "esxtop batch output file",
                            self.dirname, "", "*.*", wx.OPEN)

        if dlg.ShowModal()==wx.ID_OK:
            self.filename=dlg.GetFilename()
            self.dirname=dlg.GetDirectory()
            dlg.Destroy()

        if self.filename != '':
            fpath = self.dirname+'/'+self.filename

            if os.path.exists(fpath) == False:
                print("?File not found - "+sys.argv[1])
                exit()


            try:
                # we have a valid filename, let's get this Party started
                v = DataSource( fpath)
            except (ValueError,csv.Error)as err:
                self.MyAlert(fpath + " doesn't seem to be an estop data set,"\
                   + str(err))
                return

            self.datavector = v # set datavector so other
                                # methods can find the info
            self.tree.MyTreeLoad(v)        # bring up the GUI
            self.MyTextUpdate(self.datavector.FileInfoString)
            self.isDatasetLoaded = True
            return


    def OnImportQueries(self, event):
        """
        Load saved queries from a file
        """

        if self.datavector == None:
            self.MyAlert("You need to load a dataset first!")
            return

        dirname = ''
        filename = ''
        dlg = wx.FileDialog(self, "Saved Queries file", dirname,
                            "", "*.*", wx.OPEN)

        if dlg.ShowModal()==wx.ID_OK:
            filename=dlg.GetFilename()
            dirname=dlg.GetDirectory()
            dlg.Destroy()

        if filename != '':
            fpath = dirname + '/' + filename

            if os.path.exists(fpath) == False:
                self.MyAlert("?File not found - " + sys.argv[1])
                return
            f = open(fpath,"rb")
            rawqueries = f.readlines()        # read the entire query file
            if not re.match("#%%esxplot:queries%%", rawqueries[0]):
                self.MyAlert(fpath +\
                   " doesn't seem to be an saved queries file")
                return
        v = [ q.strip('"\n') for q in rawqueries[1:]]
        for QueryString in v:
            self._applyQuery(QueryString, "GREEN")
        return




    def OnExportGraphs(self, event):
        """
        Export the plot to a graphis image file
        """
        if self.isGraphPresent:
            self.plotter.SaveFile()
        else:
            self.MyAlert("You need to plot something first")
        return

    def OnExportColumns(self, event):
        """
        Export selected columns to a CSV file
        """

        itemlist = self.tree.GetSelections()
        if len(itemlist) == 0:                  #no selections were made
            self.MyAlert("You need to select something first")
            return

        dlg = wx.FileDialog ( None, defaultDir=self.exp_column_dir,
                             style = wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT )
        if dlg.ShowModal() == wx.ID_OK:
            filename=dlg.GetFilename()
            dirname=dlg.GetDirectory()
            self.exp_column_dir = dirname
            dlg.Destroy()
            if filename != '':
                fpath = dirname+'/'+filename
            else:
                self.MyAlert("No file specified")
                return
            if os.path.exists(fpath):
                if not self.MyDialog("File exist, Overwrite?"):
                    return

            try:
                fildes = open(fpath, 'wb')
            except:
                self.MyAlert("File " + fpath +\
                    " could not be opened for writing, check permissions")
                return
            # open the csv file to write the selections to
            # make the output reloadable to esxplot
            v = csv.writer(fildes, quoting=csv.QUOTE_ALL, dialect="excel",
                           lineterminator=',\r\n')


            columnlist = ['0'] # we always dump the time column
            traversal_result = []
            for item in itemlist:
                traversal_result.extend(self.tree.MyTreeLeafList(item))
            for item in traversal_result:
                columnindex = self.tree.GetPyData(item)
                if columnindex == None:
                    continue
                columnlist.append(columnindex)

            l = [ self.datavector.labels[int(x)] for x in columnlist]
            labelinfo = [ x.rsplit('\\',1)[0] for x in l]
            v.writerow(labelinfo)        #write out the label information

            for i in xrange(self.datavector.samplemag):
                rowvalues =\
                   [str(self.datavector.columns[int(x)][i]) for x in columnlist]
                v.writerow(rowvalues)

            fildes.close()

        return

    def OnExportQueries(self,event):
        """
        Export the current query set to a query file that can be loaded later
        """
        if not self.datavector:
            self.MyAlert("No queries are loaded")
            return

        if not self.datavector.reQueries:
            self.MyAlert("You need some Queries to Export!")
            return

        dlg = wx.FileDialog ( None, style = wx.OPEN )
        if dlg.ShowModal() == wx.ID_OK:
            filename=dlg.GetFilename()
            dirname=dlg.GetDirectory()
            dlg.Destroy()
            if filename != '':
                fpath = dirname+'/'+filename
            else:
                self.MyAlert("No file specified")
                return
            if os.path.exists(fpath):
                if not self.MyDialog("File exist, Overwrite?"):
                    return
            try:
                fildes = open(fpath,'wb')
            except:
                self.MyAlert("File " + fpath +\
                    " could not be opened for writing, check permissions")
                return
            fildes.write("#%%esxplot:queries%% " + version + " Saved Queries\n")
            for q in self.datavector.reQueries:
                fildes.write('"' + q + '"\n')
            fildes.close()
        return

    # Widget Call backs
    def OnSelection(self, event):
        '''
        Method called when selected item is changed ( click on a metric and
        it will be plotted.  This is the main routine that does the plotting
        '''


        selectionlist =\
            [ self.tree.GetPyData(x)  for x in self.tree.GetSelections()\
                if self.tree.GetPyData(x) != None ] #filter out trunk selections
        #log("SelectionList = "+str(selectionlist))
        if len(selectionlist) == 0:                  #no selections were made
            self.itemlist = []
            return

        if len(selectionlist) > len(self.color): #too many selections were made
            self.MyAlert("You can only plot a maximum of " +\
                str(len(self.color))+" metrics in a single graph")
            return

        if len(selectionlist) == 1:
            # stupid windows implementation sends bogus
            # event on multiple selection
            if (len(self.itemlist) == 1) and (isWindowsG):
                return
            self.itemlist= selectionlist[:]
        else:
            self.itemlist.extend(list(set(selectionlist) - set(self.itemlist)))

        colorindex = 0
        line = []
        for item in self.itemlist:
            columnindex = item

            # User selected a non-leaf node, (no data present)
            if columnindex == None:
                continue

            # Make sure, it's an integer and not a string object
            columnindex = int(columnindex)

            # reference the column data list, the number of samples
            # and the time quanta from the DataSource object
            columndata = self.datavector.columns[columnindex]
            numberofsamples = self.datavector.samplemag
            timequanta = round(self.datavector.timedelta)
            labelinfo = self.datavector.labels[columnindex].split('\\')
            title = labelinfo[2]
            legend = labelinfo[3] + ': ' + labelinfo[4]

            if (self.lgndlen>0) & (len(legend) > self.lgndlen):
                    legend = "..."+legend[len(legend)-self.lgndlen:]
            elif (self.lgndlen == 0):
                legend = ""

            # use a list comprehension with xrange to create the
            # co-ordinate tuples
            data = [(self.datavector.time_axis[x-1],\
                float(columndata[x])) for x in xrange (1, numberofsamples)]

            float_data = [float(columndata[x])\
                for x in xrange(1, numberofsamples)]

            # draw points as a line
            line.append(wxPlot.PolyLine(data,
                        legend=legend,
                        colour=self.color[colorindex%len(self.color)],
                        width=self.line_width))
            colorindex += 1

            mmm= minmaxavg_fmt.format(labelinfo[3] + "/" + labelinfo[4],
                                      min(float_data), max(float_data),
                                      sum(float_data)/len(float_data),
                                      scoreatpercentile(float_data, 90) )

            self.MyTextUpdate(mmm)
        #Label for the X axis
        xaxislabel = 'Time(sec) : Start Time: ' + self.datavector.starttime +\
            '  :  End Time: ' +\
            self.datavector.endtime + ' : Sample period = ' +\
            str(timequanta) + ' seconds'

        #Instantiate the Graphics Context
        gc = wxPlot.PlotGraphics(line, title, xaxislabel, 'y axis')

        # Let 'er Rip!
        self.plotter.Draw(gc)
        self.isGraphPresent = True


        return

    def OnSearchQuery(self, event):
        """
        Method called when a user types a search query that will be
        applied to the loaded tree of esxtop metrics
        """
        if self.isDatasetLoaded:
            qstring = self.queryText.GetValue()
            if qstring == "":
                self.MyAlert("You entered a blank query!")
                return
            else:
                self._applyQuery(qstring,"ORANGE")
        else:
            self.MyAlert("You need to load a dataset first!")
        return

    def _applyQuery(self, regExString, color="BLUE"):
        """
        This Method actually does the regex search of the dataset and
        displays the new query
        """

        try:
            regExObject = re.compile(
                                     self._raw(regExString.rstrip('\n')),
                                     re.IGNORECASE|re.VERBOSE)
        except:
            self.MyAlert("Unrecognizable Regular Expression!")
            return
        query_display = (regExString.strip()).replace('\n',' ')
        # create a tree to hold the result set
        result_set_tree = HvTree('%%SearchResult%%')
        dlg = wx.ProgressDialog("Search Progress" , "",
                                 maximum =self.datavector.colmag,
                                 style=wx.PD_ELAPSED_TIME|wx.PD_AUTO_HIDE)

        if len(regExString) > MAXDisplayQueryLength:
            query_display = regExString[:MAXDisplayQueryLength] + "..."

        for j in xrange(self.datavector.colmag-1): # ugly, fix me
            if j % 100 ==0:
                    dlg.Update(j)
            # if no match go to the next one
            if regExObject.search(self.datavector.l[j]) == None:
                continue

            ### Apply the WHERE clause here if there is one ###

            # turn label into a list of path elements
            m = self.datavector.l[j].split('\\')
            m[2] = 'Query: ' + query_display
            # add the path into the t-node tree, truncating the
            # two null elements at the front of the list
            result_set_tree.addMetric([ m[k] for k in xrange (2, len(m))])
        if result_set_tree.isZero():
            self.MyAlert("Empty Result set for query:\n " + regExString)
        else:
            self.tree.merge(self.datavector, result_set_tree,color)
            dlg.Update(self.datavector.colmag)
            # save the query in case user wants to save favorites
            self.datavector.AddQueryString(regExString)
        dlg.Destroy()
        return

    def _raw(self,text):
        """Returns a raw string representation of text"""
    # this is a translation dictionary and function to fix the input
    # a user types into the area, this enables a user to "cut and paste"
    # regex right out of their egrep scripts and have it work without
    # fiddling with the expression itself
        escape_dict={'\a': r'\a',
               '\b': r'\b',
               '\c': r'\c',
               '\f': r'\f',
               '\n': r'\n',
               '\r': r'\r',
               '\t': r'\t',
               '\v': r'\v',
               '\'': r'\'',
               '\"': r'\"',
               '\0': r'\0',
               '\1': r'\1',
               '\2': r'\2',
               '\3': r'\3',
               '\4': r'\4',
               '\5': r'\5',
               '\6': r'\6',
               '\7': r'\7',
               '\8': r'\8',
               '\\': r'\\',
               '\9': r'\9'}


        new_string=''
        for char in text:
            try: new_string += escape_dict[char]
            except KeyError: new_string += char
        return new_string



    def OnRightClick(self, event):
        """
        Handle right-clicks on a selection, throw up a context menu with
        possible options
        """
        self.PopupMenu(MyPopupMenu(self), (-1, -1))
        return

    def OnCloseDataset(self, event):
        """
        Close the current dataset and attempt to release all of the created
        objects and data structures
        """
        if not self.isDatasetLoaded:
            self.MyAlert("No dataset is currently open!")
            return
        # might need to perform actions... see DataSource
        self.datavector = None
        # might need to perform actions ... see MyTreeCtrl
        self.tree.DeleteAllItems()
        self.plotter.Clear()
        self.isDatasetLoaded = False
        self.isGraphPresent = False



class MyHelpDialog(wx.Dialog):
    """
    A simple Dialog Widget that is used to display the preferences window
    """

    def __init__(self, html_page=""):
        wx.Dialog.__init__(self, None, -1, 'Help', size=(800, 500),
                           style=wx.CAPTION)
        okButton = wx.Button(self, wx.ID_OK, "OK", pos=(350, 445))
        okButton.SetDefault()

class MyPopupMenu(wx.Menu):
    def __init__(self, parent):
        wx.Menu.__init__(self)

        self.parent = parent

        delete = wx.MenuItem(self, wx.NewId(), 'Delete')
        self.AppendItem(delete)
        self.Bind(wx.EVT_MENU, self.OnDelete, id=delete.GetId())

        export = wx.MenuItem(self, wx.NewId(), 'Export')
        self.AppendItem(export)
        self.Bind(wx.EVT_MENU, self.OnExport, id=export.GetId())


    def OnDelete(self, event):
        if self.parent.MyDialog("Delete this branch?"):
            itemlist = self.parent.tree.GetSelections()
            if len(itemlist) == 0:                  #no selections were made
                return

            if len(itemlist) > 1:         #too many selections were made
                self.parent.MyAlert("You can only right click on a "
                                    "single selection")
                return
            self.parent.tree.DeleteChildren(itemlist[0])
            self.parent.tree.Delete(itemlist[0])
        else:
            return

    def OnExport(self, event):
        self.parent.OnExportColumns(None)
        return






class MyApp(wx.App):
    '''Our application class (basically main() )
    '''
    def OnInit(self):
        '''Initialize by creating the split window with the tree.  Also
        determine the type of OS we are running on and process any
        cli command args that may have been passed. Read in the 
        csv file and set up datastructures.
        '''
        # discover what kind of OS we are running on
        # (note: isWindowsG is a global!)
        global isWindowsG
        if os.name == 'nt':
            isWindowsG = True
        else:
            isWindowsG = False


        # process command line arguments
        parser = OptionParser(usage="usage: %prog [options] [dataset]")
        parser.add_option("-d", "--debug", dest="debug",
                          action="store_true", default=False,
                          help="output logs to the console")
        parser.add_option("-l", "--logpath", dest="logpath",
                          type="string", default=None,
                          help="path to write the logfiles to")
        (opts, args) = parser.parse_args()

        if isWindowsG:
            logfile_path = os.path.expanduser("~") +\
                "\Local Settings\Application Data\esxplot"
            logfile_name = "\esxplot.log"
        else:
            logfile_path = os.path.expanduser("~") + "/.esxplot"
            logfile_name = "/esxplot.log"


        if opts.debug:
            logfile_path = None
            logfiledes = sys.stdout
        if opts.logpath:
            logfile_path = opts.logpath


        if logfile_path:
            if not os.access(logfile_path, os.F_OK):
                try:
                    os.makedirs(logfile_path, 0744)
                except:
                    print("Can't creat log file in " + logfile_path)

            try:
                logfiledes =  open(logfile_path + logfile_name, "a+")
                sys.stderr = logfiledes
            except:
                print("Can't open logfile " + logfile_path+logfile_name +\
                    " defaulting to stdout")
                logfiledes = sys.stdout
        else:
            logfiledes = sys.stdout


        self.savestdout = sys.stdout
        self.savestderr = sys.stderr
        sys.stdout = logfiledes
        sys.stderr = logfiledes
        log("Start run esxplot")



        if len(args) == 0:   # called with no arguments, just start the GUI
            v = None
        else:     # must have a filename argument, check it and read the data
            if os.path.exists(args[0]) == False:
                log("?File not found - " + args[0])
                self._errstop()
            else:
                try:
                    v = DataSource(args[0])
                except (ValueError , csv.Error):
                    log("?File does not seem to be an esxtop data set - " + \
                        args[0])
                    self._errstop()


        frame = MyFrame(None, -1, 'esxplot', v)
        frame.Show(True)
        self.SetTopWindow(frame)
        return True

    def _errstop(self):
        sys.stdout = self.savestdout
        sys.stderr = self.savestderr
        log(" Stop run esxplot")
        exit(2)



man_page ="""
     <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<html>
<head>
<title>ESXPLOT(1) manual page</title>
</head>
<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
esxplot - plot data from esxtop batch mode
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<b>esxplot[.py]
</b> <b>[-d | -l </b> <i>logfile_path</i>  <b>]</b> <b>[</b> <i>data_file</i>
<b>] </b>
<h2><a name='sect2' href='#toc2'>Description</a></h2>
<b>esxplot</b> is a GUI application
that lets you explore the data collected by  <b>esxtop</b> in batch mode.
The program
takes a single command line argument which is the esxtop batch mode output
file.  You can also  simply start  <b>esxplot</b> without any arguments,
and enter
a dataset file via the  <i>File</i> attribute of the menu bar. Esxplot loads the
data in this file and presents the metrics as a hierarchical tree where
the values are selectable in the left panel. In the right panel, a graph
is plotted (value over time) of the selected metric, in this way, you can
"browse" the contents of these somewhat unwieldy files.
<p> Once you load a
data set, the name of the machine will appear at the root node of a treectrl
navigation widget at the lower left side of the tool. if you double-click
on the name, all of the available categories of the metrics gathered for
this machine will appear in an alphabetically sorted tree. Click on one
of these branches to display the leaves. Clicking on a leaf activates the
plot for that metric.  Nodes and Leaves that are "greyed out" can still
be plotted but the greying is an indication to you that the values of these
graphs will be zero allong the Y axis. Holding down the  <i>Ctrl</i> key while
making a mouse selection will allow for multiple selections to be plotted,
up to a maximum of sixteen. Time based data is plotted in the large window
on the right, the host name is present on the top of the graph, to the
right of the graph there is a legend, with the name of the category and
metric for each line plotted,  the legend can be abbreviated by changing
a value in the  <i>preferences</i> dialogue panel.  You can export the plots as
a .jpg, ,png and .bmp.
<p> <b>Esxplot</b> allows you to zoom into a plot to examine
elements of the plot at a fine level of granulation.  To do this, place
the mouse in the plotting canvas, depress and hold left-button while you
drag to describe a bounding rectangle encompassing the area of the plot
that you want to examine more closely, when you release the left-button
the graph is redrawn within the boundaries of the area that you inscribed.
To zoom back out to baseline, double-click the left-button.
<p> The application
is constructed in such a way that the plotting area can be expanded and
contracted along the left side of the plotting area. To do this, position
the mouse over the boundary between the treecontrol/textcontrol area and
the plotting canvas, approximately in the center, hold left-button down
and drag to the right or the left to resize the plotting canvas.
<p> The panel
on the left contains a status text window where information and statistics
will appear as esxplot goes about its work.   This window is read-only.
<b>Esxplot </b> prints messages upon start-up, when you load a dataset, and also
when you select a metric for plotting, when the metric is selected, the
Min, Max, and Mean values for the metric are printed in this window.  The
window scrolls so no data is lost during your browsing session.  You can
also copy data from this section to paste into other applications.
<p> Beneath
that, there is a  second text window which is writeable.  This window allows
you to enter complex multi line regular expressions, which will be applied
against the metric descriptions for the columns making up the treecontrol.
 Pleae note that you must click the <i>GO</i> button in order to execute
the query,
ending the query by a carriage return will not cause the query to be executed
as you are allowed to enter regular expressions that are several lines
long.  If the query is valid and a result set is produced, the treecontrol
is collapsed and another branch named Query:xxx is displayed where xxx
are the first few characters of the query.  If the query is malformed or
if there isn&rsquo;t a match, an Alert Dialogue is asserted, click OK and try
a different query. It should be possible to cut and paste complicated queries
that you have previously used in <b>egrep</b> into this text area and hit the
GO button and have them applied against the set of metric names found in
the treecontrol.  The results of the query, if it is successful, is another
treecontrol branch that can be navigated in the same way.  Queries are always
applied against the main branch and never against the result of previous
queries.
<p> <b>Esxplot</b> has a single menu button,  <i>File.</i>
<p> Underneath this menu
we have  <i>About,</i> <i>Import,</i> <i>Export,</i> <i>Close,</i>
<i>Preferences,</i> <i>Help</i> and <i>Exit</i>
<p> <b>About</b>
<blockquote>Displays general information about <b>esxplot</b> including
version and license
information. </blockquote>

<p> <b>Import-&gt;Dataset</b>
<p> <blockquote>The  <i>Dataset</i> submenu allows you to import data
set into  <b>esxplot</b> to be processed.  These data sets are the output of the
<b>esxtop</b> command run in batch mode (see the collecting data section below).
A general file selection dialog box will appear which allows you to select
a file for import.  There are no restrictions on file name or extension,
but esxplot will do some basic checking to insure that it is actually a
dump originating from esxtop that you are loading. As of this release, you
can only import a single data set per run of esxplot. </blockquote>

<p> <b>Import-&gt;Queries</b>
<p> <blockquote>You
can read in queries that you have used and saved in previous runs of esxplot.
 You can also craft canned queries and place them in a query file for use
later.  The format of these files are rather straight forward and can be
deduced easily by examining one.  Please note that this format could change
in subsequent releases. You can only import queries if you have a data set
already imported. Queries that are imported from a saved queries file are
immediately applied, one by one, against the metric fields in the data
set loaded,  if a query fails to produce a result set, that query is essentially
deleted. </blockquote>

<p> <b>Export-&gt;Graph</b>
<p> <blockquote>This submenu allows you to export the plot canvas
to a file in a particular image format.
Allowable formats are  <i>.bmp</i> <i>.xbm</i> <i>.xpm</i>
<i>.png</i>  and <i>.jpg</i>
<p> To have the file exported in a particular format, simply
tag the output file with the appropriate extension for the format that
you wish to write to. Note that the size of the resultant image file depends
on the size of the canvas that esxplot is currently displaying, i.e. to get
the maximum size plot, Maximize esxplot and slide the panel slider far
to the left. </blockquote>

<p> <b>Export-&gt;Columns</b>
<p> <blockquote>You can also export a subset of column data
with esxplot.  Basically the Export-&gt;Columns menu will export the metrics
that are currently selected at the time that the menu is activated.  If
you make selections that are plotted (up to 16) they will be exported to
a CSV file. However this feature is more powerful then just selecting the
plotted metrics.  Any branch of the treecontrol that is selected will be
exported as a CSV file. If you select the top of the tree, then the entire
tree is exported (not very useful). But this goes all the way to the result
set of a query! So, if you select the query that you just entered or imported
and activate File-&gt;Export-&gt;Columns, then the results of that query will be
exported to a CSV file that is suitable for reload into esxplot or other
utilities such as PERFMON or Excel,  this is a quick way to cut up those
esxtop output files that have over 100,000 columns! </blockquote>

<p> <b>Export-&gt;Queries</b>
<p> <blockquote>The
final submenu under Export is the  <b>Queries</b> submenu.  This allows you to
export all of your currently active queries to a file for later use.  Note
that this feature exports the queries themselves, not the result sets of
the queries.  To export the result sets, select the query and use the export
columns feature. The file produced can be read in to load these queries
during a latter run. </blockquote>

<p> <b>Right-Mouse-Down on  Selections</b> <blockquote><i>Right-Mouse-Down</i>
on a
selection made in the treectrl widget, brings up a context menu with two
options,
<p> <i>delete,</i>  which will delete the particular branch of the treectrl
that is selected.  This is primarily used to delete unwanted query result
sets. You cannot delete single metrics or multiple selections using this
feature, only entire data sets, or query result sets. Note that in order
to load a new dataset, you must use the  <b>Close</b> menu item to
close the Current
Dataset.
<p> <i>export,</i>  which will bring up a file selection dialog box that
will allow you to save your selctions to a csv file.  You can save multiple
selections, as well as the entire result set of a query this way. </blockquote>
<b>Close</b>

<p> <blockquote>This menu item currently has one element,
<i>Current Dataset</i>. Selecting this
will close the current dataset, clear the navigation panel and graphic
area.  You can now Import a new dataset into the tool. As you import larger
datasets, the virtual address space of esxplot increases. However, if you
unload a large dataset, the memory is garbage collected by python so opening
a dataset that is smaller in size will not demand additional memory.
</blockquote>

<p> <b>Preferences</b>

<p> <blockquote>This displays a panel with set-able parameters that control
the way esxplot
behaves.  For the 1.0 release there are not a lot of dials. You can set the
width of the plot lines to either one pixel wide (the default) or to two
pixels wide, which is sometime useful if you are creating a printed document.
The abbreviated legends check box, if checked, allows you to enter a two
digit integer in the textbox to the right, the number you enter here will
be the rightmost number of characters displayed on the legends that are
situated to the right of the graph area.  This box is not checked by default.

<p> Finally you can set the colors of the lines that are used to plot the
graphs, there are over 630 colors in the wxPython color database and you
can select these by name, you can also enter an RGB value by prefixing
the 6 digit hex value with a "#", so, for example "#0000FF" is pure blue,
where as "#FF0000" is red.   Pressing the  <i>Reset to Default Colors</i> Button
will reload the default colors, just in case you changed them to something
that you don&rsquo;t like. When you click OK on the preferences panel
the preferences
take effect and the plot is redrawn with the new values. </blockquote>

<p> <b>Help</b> <blockquote>Your reading
it :) </blockquote>
<b>Exit</b>
<p> <blockquote>What more needs to be said? </blockquote>

<p>
<h2><a name='sect3' href='#toc3'>Collecting Data</a></h2>

<p> The simplest way
to collect data is to run esxtop in batch mode and tell it to collect everything,
to do this run the following command from the service console of your ESX
host or from the vMA of your ESXi host:
<p> <font size='-1'>esxtop -a -b -n 120 &gt; dataset.csv</font>

<p>
This command will collect all metrics with a time interval of 5 seconds
(the default) and take 120 samples (about 10 minutes). This resultant file
is the target of an  <i>Import-&gt;Dataset</i> action. Use caution when you use the
 <b>-a</b> switch to esxtop on a system with a large number of virtual machines,
you could wind up with a file that has well over 50 to 100 thousand columns.
 While esxplot can handle data sets this large, having to wade through
all of that data makes response time sluggish, especially if your running
it on a Microsoft Windows desktop. If this is the case, it may be better
to run esxtop on the target system in interactive mode, select a subset
of the areas that you are interested in, perform the "W" command to write
out an "rc" file and use this file to run esxtop in batch mode as follows:

<p> <font size='-1'>esxtop -b -c esxtoprc -n 120 &gt; dataset.csv</font>

<p> where esxtoprc is the name of the
rc file that you saved during the interactive run.
<p>
<h2><a name='sect4' href='#toc4'>Options</a></h2>
<b>-d</b> <blockquote>Run esxplot
forcing all logging to  <i>stdout</i> and not to a log file </blockquote>
<b>-l</b> <i>logfile_path</i> <blockquote>Log
to the specified logfile and not to the default location,
(~/.esxplot/esxplot.log
on *nix systems,
\Documents and Settings\&lt;user&gt;\Local Settings\Application Data\esxplot\esxplot.log
for Windows systems) </blockquote>
<i>data_file</i> <blockquote>If you start esxplot from the command line,
you can specify a filename that will immediately be loaded upon when the
application starts </blockquote>

<h2><a name='sect5' href='#toc5'>Files</a></h2>
<i>data_file</i> <blockquote>A file in excel "csv" format, typically
originating from the output of <b>esxtop</b> in batch mode. </blockquote>
<i>query_file</i> <blockquote>These files
are produced by esxplot and contain queries that can be used when you run
<b>esxplot</b> at a latter time. </blockquote>
<i>image_file</i> <blockquote><b>Esxplot</b> can produce an image file of
the plot in several formats, exporting the file with the appropriate extension
will yeild an image file in that format. </blockquote>

<p>
<h2><a name='sect6' href='#toc6'>Environment</a></h2>
This program was written
in Python 2.6, and needs the  <i>wxPython</i> library <i>2.8.10</i> or
greater,along with
 the <i>numpy</i> library <i>1.3.0</i> or greater.  <i>WxPython</i> allows
you to write GUI programs
that will run on *NIX, Windows and OSX without change.  If you are so lucky
to have a <i>thinapp</i> or other type of installable for windows, you can just
double-click on the icon and get going.
<p>
<h2><a name='sect7' href='#toc7'>Diagnostics</a></h2>
Alerts will appear if
you&rsquo;ve done something wrong.  Otherwise, if the application dies
mysteriously,
or hangs, try looking in the logfile or console for a traceback.  Send the
traceback to &lt;geoffw at durganetworks dot com&gt;
<p>
<h2><a name='sect8' href='#toc8'>Bugs</a></h2>
Report all bugs, misfeatures,
and feature requests to the author.
<p>
<h2><a name='sect9' href='#toc9'>Author</a></h2>
Geoff White &lt;geoffw at durganetworks
dot com&gt;
<p>
<h2><a name='sect10' href='#toc10'>See Also</a></h2>
<a href='esxtop.1'>esxtop (1)</a>

<p> There is also an excellent whitepaper on interpreting
esxtop statistics  at...
<p> <a href='http://communities.vmware.com/docs/DOC-9279'>
http://communities.vmware.com/docs/DOC-9279</a>

<p> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Collecting Data</a></li>
<li><a name='toc4' href='#sect4'>Options</a></li>
<li><a name='toc5' href='#sect5'>Files</a></li>
<li><a name='toc6' href='#sect6'>Environment</a></li>
<li><a name='toc7' href='#sect7'>Diagnostics</a></li>
<li><a name='toc8' href='#sect8'>Bugs</a></li>
<li><a name='toc9' href='#sect9'>Author</a></li>
<li><a name='toc10' href='#sect10'>See Also</a></li>
</ul>
</body>
</html>
"""

def main():
    #Sorta the main program
    app = MyApp(0)
    app.MainLoop()
    #sys.stdout = app.savestdout


if __name__ == '__main__':

    main()

